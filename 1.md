// npm i ws
const http = require("http");
const net = require("net");
const WebSocket = require("ws");

const PORT = process.env.WS_PORT || 8080;

function stripTelnet(buf) {
  // Remove basic Telnet IAC negotiation so the browser sees clean text
  const IAC = 255, SE = 240, SB = 250;
  let out = [];
  for (let i = 0; i < buf.length; i++) {
    if (buf[i] === IAC) {
      const cmd = buf[++i];
      if (cmd === SB) {
        // skip until IAC SE
        while (i < buf.length && !(buf[i] === IAC && buf[i + 1] === SE)) i++;
        i++; // skip SE
      } else {
        i++; // skip option byte for WILL/WONT/DO/DONT/etc.
      }
      continue;
    }
    out.push(buf[i]);
  }
  return Buffer.from(out);
}

const server = http.createServer();
const wss = new WebSocket.Server({ server });

wss.on("connection", (ws, req) => {
  const url = new URL(req.url, "http://localhost");
  const host  = url.searchParams.get("host")  || "cluster.om0rx.com";
  const port  = parseInt(url.searchParams.get("port") || "7300", 10);
  const login = url.searchParams.get("login") || "om0rx";

  const tcp = net.createConnection({ host, port }, () => {
    // small delay lets the banner/prompt arrive first
    setTimeout(() => tcp.write(login + "\r\n"), 400);
  });

  tcp.on("data", (data) => {
    const clean = stripTelnet(data).toString("utf8");
    if (ws.readyState === WebSocket.OPEN) ws.send(clean);
  });

  tcp.on("error", (err) => {
    if (ws.readyState === WebSocket.OPEN) ws.send(`[TCP ERROR] ${err.message}\n`);
    try { ws.close(); } catch {}
  });

  tcp.on("close", () => {
    try { if (ws.readyState === WebSocket.OPEN) ws.close(); } catch {}
  });

  ws.on("message", (msg) => {
    const text = msg.toString();
    // Ensure CRLF line endings for Telnet servers
    tcp.write(text.endsWith("\n") ? text.replace(/\n$/, "\r\n") : text + "\r\n");
  });

  ws.on("close", () => {
    try { tcp.end(); } catch {}
  });
});

server.listen(PORT, () => {
  console.log(`WS–Telnet bridge listening on :${PORT}`);
});


<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DX Cluster Web Client</title>
<style>
  body { font-family: system-ui, sans-serif; margin: 0; background:#0b0d10; color:#e6edf3; }
  header { padding: 12px 16px; background:#11161c; border-bottom:1px solid #1f2630; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  input, button { padding:8px 10px; border-radius:8px; border:1px solid #2b3440; background:#0f141a; color:#e6edf3; }
  button { cursor:pointer; }
  #status { margin-left:auto; font-size:12px; opacity:0.8; }
  #term { padding:12px 16px; height:60vh; overflow:auto; white-space:pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  #sendbar { display:flex; gap:8px; padding:8px 16px; border-top:1px solid #1f2630; background:#0d1218; }
  #cmd { flex:1; }
  .line { margin:0; }
  .rx { color:#b3e5ff; }
  .tx { color:#9be28f; }
  .sys { color:#ffcf8e; }
</style>
</head>
<body>
  <header>
    <label>Host <input id="host" value="cluster.om0rx.com"></label>
    <label>Port <input id="port" value="7300" size="6"></label>
    <label>Login <input id="login" value="om0rx"></label>
    <button id="connect">Connect</button>
    <button id="disconnect" disabled>Disconnect</button>
    <button id="showdx" disabled>sh/dx</button>
    <div id="status">disconnected</div>
  </header>

  <div id="term"></div>

  <div id="sendbar">
    <input id="cmd" placeholder="Type a cluster command (e.g., sh/dx, sh/wwv, sh/announce) and press Enter" />
    <button id="send" disabled>Send</button>
  </div>

<script>
let ws = null;

const term = document.getElementById('term');
const status = document.getElementById('status');
const hostEl = document.getElementById('host');
const portEl = document.getElementById('port');
const loginEl = document.getElementById('login');
const connectBtn = document.getElementById('connect');
const disconnectBtn = document.getElementById('disconnect');
const sendBtn = document.getElementById('send');
const cmdEl = document.getElementById('cmd');
const showdxBtn = document.getElementById('showdx');

function appendLine(text, cls="rx") {
  const p = document.createElement('div');
  p.className = 'line ' + cls;
  p.textContent = text.replace(/\r/g,'');
  term.appendChild(p);
  term.scrollTop = term.scrollHeight;
}

function setConnected(yes) {
  connectBtn.disabled = yes;
  disconnectBtn.disabled = !yes;
  sendBtn.disabled = !yes;
  showdxBtn.disabled = !yes;
  status.textContent = yes ? 'connected' : 'disconnected';
}

connectBtn.addEventListener('click', () => {
  const host = hostEl.value.trim();
  const port = portEl.value.trim();
  const login = loginEl.value.trim();
  // If your bridge runs elsewhere, change ws://localhost:8080 to your wss://… URL
  const url = `ws://localhost:8080/?host=${encodeURIComponent(host)}&port=${encodeURIComponent(port)}&login=${encodeURIComponent(login)}`;
  ws = new WebSocket(url);

  ws.addEventListener('open', () => {
    setConnected(true);
    appendLine(`[Connected → ${host}:${port} as ${login}]`, 'sys');
  });

  ws.addEventListener('message', (ev) => {
    appendLine(ev.data, 'rx');
  });

  ws.addEventListener('close', () => {
    setConnected(false);
    appendLine('[Connection closed]', 'sys');
  });

  ws.addEventListener('error', (e) => {
    appendLine('[WebSocket error]', 'sys');
  });
});

disconnectBtn.addEventListener('click', () => {
  if (ws && ws.readyState === WebSocket.OPEN) ws.close();
});

sendBtn.addEventListener('click', sendCurrent);
cmdEl.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') sendCurrent();
});

showdxBtn.addEventListener('click', () => {
  cmdEl.value = 'sh/dx';
  sendCurrent();
});

function sendCurrent() {
  const text = cmdEl.value.trim();
  if (!text || !ws || ws.readyState !== WebSocket.OPEN) return;
  ws.send(text);
  appendLine(`> ${text}`, 'tx');
  cmdEl.value = '';
  cmdEl.focus();
}
</script>
</body>
</html>
